package processor

import (
	"context"
	"errors"
	"fmt"
	"github.com/intelops/compage/core/internal/core"
	"github.com/intelops/compage/core/internal/languages"
	"github.com/intelops/compage/core/internal/languages/golang"
	"github.com/intelops/compage/core/internal/utils"
	log "github.com/sirupsen/logrus"
	"os"
	"strings"
)

// Process called from rest as well as gRPC
func Process(coreProject *core.Project) error {
	// create a directory with project name to contain code generated by core.
	projectDirectory := utils.GetProjectDirectoryName(coreProject.Name)
	if err := utils.CreateDirectories(projectDirectory); err != nil {
		return err
	}

	// Iterate over all nodes and generate code for all nodes.
	compageJson := coreProject.CompageJson
	for _, compageNode := range compageJson.Nodes {
		log.Debugf("processing node ID : %s ", compageNode.ID)

		// convert node to languageNode
		languageNode, err := languages.NewLanguageNode(compageJson, compageNode)
		if err != nil {
			// return errors like certain protocols aren't yet supported
			log.Debugf("err : %s", err)
			return err
		}

		// add values(LanguageNode and configs from coreProject) to context.
		languageCtx := languages.AddValuesToContext(context.Background(), coreProject, languageNode)

		// extract nodeDirectoryName for formatter
		values := languageCtx.Value(languages.LanguageContextVars).(languages.Values)
		nodeDirectoryName := values.NodeDirectoryName

		// create node directory in projectDirectory depicting a subproject
		if err0 := utils.CreateDirectories(nodeDirectoryName); err0 != nil {
			log.Debugf("err : %s", err0)
			return err0
		}

		// process golang
		if languageNode.Language == languages.Go {
			// add values(LanguageNode and configs from coreProject) to context.
			goCtx := golang.AddValuesToContext(languageCtx)
			if err1 := golang.Process(goCtx); err1 != nil {
				log.Debugf("err : %s", err1)
				return err1
			}
		} else {
			/* process all languages. This means that the template is of openApi type.*/
			// process rest server config.
			if languageNode.RestConfig != nil {
				// process only openApi template here.
				if languageNode.RestConfig.Server.Template != languages.OpenApi {
					return errors.New(fmt.Sprintf("unsupported template %s for language %s", languageNode.RestConfig.Server.Template, languageNode.Language))
				}
				// check if OpenApiFileYamlContent contains value.
				if len(languageNode.RestConfig.Server.OpenApiFileYamlContent) < 1 {
					return errors.New("at least rest-config needs to be provided, OpenApiFileYamlContent is empty")
				}

				if err0 := ProcessOpenApiTemplate(languageCtx); err0 != nil {
					return err0
				}

				//TODO copy kubernetes yaml's
			} else {
				return errors.New("at least rest-config needs to be provided, OpenApiFileYamlContent is empty")
			}
		}
	}

	return nil
}

func ProcessOpenApiTemplate(ctx context.Context) error {
	values := ctx.Value(languages.LanguageContextVars).(languages.Values)

	// create a file out of openApiYamlContent in request.
	fileName, err := writeFile(values.LanguageNode.RestConfig.Server.OpenApiFileYamlContent)
	if err != nil {
		log.Debugf("err : %s", err)
		return err
	}

	// generate code by openapi.yaml
	if err0 := languages.RunOpenApiGenerator("generate", "-i", fileName, "-g", strings.ToLower(values.LanguageNode.RestConfig.Server.Framework), "-o", values.NodeDirectoryName, "--git-user-id", values.TemplateVars[languages.UserName], "--git-repo-id", values.TemplateVars[languages.RepositoryName]+"/"+values.LanguageNode.Name); err0 != nil {
		log.Debugf("err : %s", err0)
		return errors.New("something happened while running openApi generator")
	}

	// generate documentation for the code

	if err1 := languages.RunOpenApiGenerator("generate", "-i", fileName, "-g", "dynamic-html", "-o", values.NodeDirectoryName+"/gen/docs", "--git-user-id", values.TemplateVars[languages.UserName], "--git-repo-id", values.TemplateVars[languages.RepositoryName]+"/"+values.LanguageNode.Name); err1 != nil {
		log.Debugf("err : %s", err1)
		return errors.New("something happened while running openApi generator for documentation")
	}
	return nil
}

func writeFile(content string) (string, error) {
	file, err := os.CreateTemp("/tmp", "openapi")
	if err != nil {
		return "", err
	}

	defer func(f *os.File) {
		_ = f.Close()
	}(file)

	_, err0 := file.WriteString(content)

	return file.Name(), err0
}
