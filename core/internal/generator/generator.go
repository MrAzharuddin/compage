package generator

import (
	"context"
	"errors"
	"fmt"
	"github.com/intelops/compage/core/internal/core"
	"github.com/intelops/compage/core/internal/languages"
	"github.com/intelops/compage/core/internal/languages/golang"
	"github.com/intelops/compage/core/internal/utils"
	log "github.com/sirupsen/logrus"
	"os"
	"strings"
)

// Generate called from rest as well as gRPC
func Generate(coreProject *core.Project) error {
	// create a directory with project name to contain code generated by core.
	projectDirectory := utils.GetProjectDirectoryName(coreProject.Name)
	if err := utils.CreateDirectories(projectDirectory); err != nil {
		return err
	}

	// Iterate over all nodes and generate code for all nodes.
	compageJson := coreProject.CompageJson
	for _, compageNode := range compageJson.Nodes {
		log.Debugf("processing node ID : %s ", compageNode.ID)

		// convert node to languageNode
		languageNode, err1 := languages.NewLanguageNode(compageJson, compageNode)
		if err1 != nil {
			// return errors like certain protocols aren't yet supported
			log.Debugf("err : %s", err1)
			return err1
		}

		// add values(LanguageNode and configs from coreProject) to context.
		languageCtx := languages.AddValuesToContext(context.Background(), coreProject, languageNode)

		// extract nodeDirectoryName for formatter
		values := languageCtx.Value(languages.LanguageContextVars).(languages.Values)
		nodeDirectoryName := values.NodeDirectoryName

		// create node directory in projectDirectory depicting a subproject
		if err2 := utils.CreateDirectories(nodeDirectoryName); err2 != nil {
			log.Debugf("err : %s", err2)
			return err2
		}

		// process golang
		if languageNode.Language == languages.Go {
			// add values(LanguageNode and configs from coreProject) to context.
			goCtx := golang.AddValuesToContext(languageCtx)
			err := ProcessGolang(goCtx)
			if err != nil {
				log.Debugf("err : %s", err)
				return err
			}
		} else {
			/* process all languages. This means that the template is of openApi type.*/
			// process rest server config.
			if languageNode.RestConfig != nil {
				// process only openApi template here.
				if languageNode.RestConfig.Server.Template != languages.OpenApi {
					return errors.New(fmt.Sprintf("unsupported template %s for language %s", languageNode.RestConfig.Server.Template, languageNode.Language))
				}
				// check if OpenApiFileYamlContent contains value.
				if len(languageNode.RestConfig.Server.OpenApiFileYamlContent) < 1 {
					return errors.New("at least rest-config needs to be provided, OpenApiFileYamlContent is empty")
				}
				err := ProcessOpenApiTemplate(languageCtx)
				if err != nil {
					return err
				}

				//TODO copy kubernetes yaml's
			} else {
				return errors.New("at least rest-config needs to be provided, OpenApiFileYamlContent is empty")
			}
		}
	}

	return nil
}

func ProcessGolang(ctx context.Context) error {
	goValues := ctx.Value(golang.GoContextVars).(golang.GoValues)

	// fills default config for golang
	err3 := goValues.GoNode.FillDefaults()
	if err3 != nil {
		log.Debugf("err : %s", err3)
		return err3
	}

	// create golang specific copier
	copier := golang.NewCopier(ctx)

	// generate golang project using custom template.
	if err4 := golang.Generator(goValues.GoNode, copier); err4 != nil {
		log.Debugf("err : %s", err4)
		return err4
	}

	// format the code generated
	err5 := RunGoFmt(goValues.Values.NodeDirectoryName)
	if err5 != nil {
		log.Debugf("err : %s", err5)
		return err5
	}
	return nil
}

func ProcessOpenApiTemplate(ctx context.Context) error {
	values := ctx.Value(languages.LanguageContextVars).(languages.Values)

	// create a file out of openApiYamlContent in request.
	fileName, err6 := writeFile(values.LanguageNode.RestConfig.Server.OpenApiFileYamlContent)
	if err6 != nil {
		log.Debugf("err : %s", err6)
		return err6
	}

	// generate code by openapi.yaml
	err7 := RunOpenApiGenerator("generate", "-i", fileName, "-g", strings.ToLower(values.LanguageNode.RestConfig.Server.Framework), "-o", values.NodeDirectoryName, "--git-user-id", values.TemplateVars[languages.UserName], "--git-repo-id", values.TemplateVars[languages.RepositoryName]+"/"+values.LanguageNode.Name)
	if err7 != nil {
		log.Debugf("err : %s", err7)
		return errors.New("something happened while running openApi generator")
	}

	// generate documentation for the code
	err8 := RunOpenApiGenerator("generate", "-i", fileName, "-g", "dynamic-html", "-o", values.NodeDirectoryName+"/gen/docs", "--git-user-id", values.TemplateVars[languages.UserName], "--git-repo-id", values.TemplateVars[languages.RepositoryName]+"/"+values.LanguageNode.Name)
	if err8 != nil {
		log.Debugf("err : %s", err8)
		return errors.New("something happened while running openApi generator for documentation")
	}
	return nil
}

func writeFile(content string) (string, error) {
	file, err := os.CreateTemp("/tmp", "openapi")
	if err != nil {
		return "", err
	}

	defer func(f *os.File) {
		_ = f.Close()
	}(file)
	_, err = file.WriteString(content)
	return file.Name(), err
}
